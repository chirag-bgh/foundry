use crate::{cmd::Cmd, opts::ClapChain};
use cast::{InterfacePath, SimpleCast};
use clap::{Parser, ValueHint};
use ethers::types::Address;
use eyre::WrapErr;
use foundry_common::fs;
use foundry_config::Config;
use futures::future::BoxFuture;
use std::path::{Path, PathBuf};

use crate::cmd::utils::{Cmd, LoadConfig};
use ethers::contract::{Abigen, ContractFilter, ExcludeContracts, MultiAbigen, SelectContracts};
use foundry_config::{
    figment::{
        self,
        error::Kind::InvalidType,
        value::{Dict, Map, Value},
        Metadata, Profile, Provider,
    },
    impl_figment_convert, Config,
};
use serde::Serialize;
use std::{
    fs,
    path::{Path, PathBuf},
};

/// CLI arguments for `cast bind`.
#[derive(Debug, Clone, Parser, Serialize)]

pub struct BindArgs {
    #[clap(
        help = "The contract address, or the path to an ABI file.",
        long_help = r#"The contract address, or the path to an ABI file.

If an address is specified, then the ABI is fetched from Etherscan."#,
        value_name = "PATH_OR_ADDRESS"
    )]
    path_or_address: String,

    
    #[clap(long, short, env = "ETHERSCAN_API_KEY", help = "etherscan API key", value_name = "KEY")]
    etherscan_api_key: Option<String>,

    #[clap(
        long = "crate-name",
        help = "The name of the Rust crate to generate. This should be a valid crates.io crate name. However, it is not currently validated by this command.",
        default_value = DEFAULT_CRATE_NAME,
    )]
    #[serde(skip)]
    crate_name: String,

    #[clap(
        long = "crate-version",
        help = "The version of the Rust crate to generate. This should be a standard semver version string. However, it is not currently validated by this command.",
        default_value = DEFAULT_CRATE_VERSION,
        value_name = "NAME"
    )]
    #[serde(skip)]
    crate_version: String,

    #[clap(long, help = "Generate the bindings as a module instead of a crate")]
    module: bool,

    #[clap(
        long = "overwrite",
        help = "Overwrite existing generated bindings. By default, the command will check that the bindings are correct, and then exit. If --overwrite is passed, it will instead delete and overwrite the bindings."
    )]
    #[serde(skip)]
    overwrite: bool,

    #[clap(long = "single-file", help = "Generate bindings as a single file.")]
    #[serde(skip)]
    single_file: bool,

    #[clap(long = "skip-cargo-toml", help = "Skip Cargo.toml consistency checks.")]
    #[serde(skip)]
    skip_cargo_toml: bool,

    #[clap(long, help = "Skips running forge build before generating binding")]
    #[serde(skip)]
    skip_build: bool,

    #[clap(flatten)]
    #[serde(skip)]
    build_args: CoreBuildArgs,

}

impl BindArgs {
    /// Get the path to the root of the autogenerated crate
    fn bindings_root(&self, artifacts: impl AsRef<Path>) -> PathBuf {
        self.bindings.clone().unwrap_or_else(|| artifacts.as_ref().join("bindings"))
    }

    /// `true` if the bindings root already exists
    fn bindings_exist(&self, artifacts: impl AsRef<Path>) -> bool {
        self.bindings_root(artifacts).is_dir()
    }

    /// Returns the filter to use for `MultiAbigen`
    fn get_filter(&self) -> ContractFilter {
        if self.select_all {
            return ContractFilter::All
        }
        if !self.select.is_empty() {
            return SelectContracts::default().extend_regex(self.select.clone()).into()
        }
        if !self.skip.is_empty() {
            return ExcludeContracts::default().extend_regex(self.skip.clone()).into()
        }
        
    }

    /// Generate the bindings
    fn generate_bindings(&self, address_or_path: InterfacePath) -> eyre::Result<()> {
        let bindings = self.get_multi(&artifacts)?.build()?;
        println!("Generating bindings for {} contracts", bindings.len());
        if !self.module {
            bindings.write_to_crate(
                &self.crate_name,
                &self.crate_version,
                self.bindings_root(&artifacts),
                self.single_file,
            )?;
        } else {
            bindings.write_to_module(self.bindings_root(&artifacts), self.single_file)?;
        }
        Ok(())
    }
}

impl Cmd for BindArgs {
    type Output = ();

    fn run(self) -> eyre::Result<Self::Output> {
        let cmd = Box::pin(async move {
            let BindArgs {
                path_or_address,
                name,
                
                output_location,
                etherscan_api_key,
                chain,
            } = self;
            let interfaces = if Path::new(&path_or_address).exists() {
                SimpleCast::generate_interface(InterfacePath::Local { path: path_or_address, name })
                    .await?
            } else {
                let api_key = etherscan_api_key.or_else(|| {
                    let config = Config::load();
                    config.get_etherscan_api_key(Some(chain.inner))
                }).ok_or_else(|| eyre::eyre!("No Etherscan API Key is set. Consider using the ETHERSCAN_API_KEY env var, or setting the -e CLI argument or etherscan-api-key in foundry.toml"))?;

                SimpleCast::generate_interface(InterfacePath::Etherscan {
                    chain: chain.inner,
                    api_key,
                    address: path_or_address
                        .parse::<Address>()
                        .wrap_err("Invalid address provided. Did you make a typo?")?,
                })
                .await?
            };

            // put it all together
            let pragma = format!("pragma solidity {pragma};");
            let interfaces = interfaces
                .iter()
                .map(|iface| iface.source.to_string())
                .collect::<Vec<_>>()
                .join("\n");
            let res = format!("{pragma}\n\n{interfaces}");

            // print or write to file
            if let Some(loc) = output_location {
                fs::create_dir_all(loc.parent().unwrap())?;
                fs::write(&loc, res)?;
                println!("Saved interface at {}", loc.display());
            } else {
                println!("{res}");
            }
            Ok(())
        });

        if self.overwrite {
            fs::remove_dir_all(self.bindings_root(&artifacts))?;
        }

        self.generate_bindings(&artifacts)?;

        println!(
            "Bindings have been output to {}",
            self.bindings_root(&artifacts).to_str().unwrap()
        );

        Ok(cmd)
    } fn run
} impl Cmd for BindArgs
